{"version":3,"sources":["/source/wario.js","/source/src/wario.js","wario.min.js"],"names":["global","factory","exports","module","define","amd","wario","this","getNested","_x","_x2","_again","obj","key","parts","split","realKey","attribute","length","slice","join","undefined","parseEach","string","pattern","rps","each","matchChunk","parsed","match","reduce","result","m","matchAttribute","matchVal","newText","map","value","replaceValues","replace","matches","rpv","parseTemplate","template","source","core","trim","indexOf"],"mappings":"CAAA,SAAWA,EAAQC,GACE,gBAAZC,UAA0C,mBAAXC,QAAyBA,OAAOD,QAAUD,IAC9D,kBAAXG,SAAyBA,OAAOC,IAAMD,OAAOH,GACpDD,EAAOM,MAAQL,KACfM,KAAM,WAAc,YCWtB,SAASC,GAAAC,EAAAC,GCQM,IAFX,GAAIC,IAAS,EAEKA,GDRO,CCSvB,GDTaC,GAAAH,EAAKI,EAAAH,CCWlBC,IAAS,CDVb,IAAMG,GAAQD,EAAIE,MAAM,KAClBC,EAAUF,EAAM,GAChBG,EAAYL,EAAII,EACtB,MAAIF,EAAMI,OAAS,GAGjB,MAAOD,ECUHR,GDZaQ,ECabP,EDbwBI,EAAMK,MAAM,GAAGC,KAAK,KCc5CT,GAAS,EDlBTG,EACAE,EACAC,EAAAI,QAQR,QAASC,GAAUC,EAAQX,GACzB,GAAMY,GAAUC,EAAIC,KAAKC,WACnBC,EAASL,EAAOM,MAAML,GAASM,OAAO,SAACC,EAAQC,GACnD,GAAInB,GAAMmB,EAAEH,MAAMJ,EAAIC,KAAKO,gBAAgB,GACvCC,EAAW1B,EAAUI,EAAKC,GAC1BsB,EAAUD,EAASE,IAAI,SAACC,GAC1B,MAAOC,GAAcN,EAAEO,QAAQd,EAAIC,KAAKa,QAAS,IAAKF,IAGxD,OAAON,GAAOQ,QAAQP,EAAGG,EAAQf,KAAK,MACrCG,EAEH,OAAOK,GAGT,QAASU,GAAcf,EAAQX,GAC7B,GAAM4B,GAAUjB,EAAOM,MAAMJ,EAAIgB,IAAIZ,MACrC,KAAKW,EAAW,MAAOjB,EACvB,IAAMK,GAASY,EAAQV,OAAO,SAACC,EAAQC,GACrC,GAAInB,GAAMmB,EAAEO,QAAQd,EAAIgB,IAAIF,QAAS,IACjCL,EAAW1B,EAAUI,EAAKC,EAC9B,OAAOkB,GAAOQ,QAAQP,EAAGE,IACxBX,EAEH,OAAOK,GAGT,QAASc,GAAcC,EAAU/B,GAC/B,GAAMgC,GAASD,EAASJ,QAAQd,EAAIoB,KAAKN,QAAQ,IAAIO,MACrD,OAAIH,GAASI,QAAQ,WAAa,GACzBT,EAAchB,EAAUsB,EAAQhC,GAAMA,GAExC0B,EAAcM,EAAQhC,GA1D/B,GAAMa,IACJoB,MACEN,QAAS,kBAEXb,MACEC,WAAY,qCACZM,eAAgB,kBAChBM,QAAS,iCAEXE,KACEZ,MAAO,eACPU,QAAS,aAXbjC,EAAAoC,CDqEE,OAAOpC","file":"wario.min.js","sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  global.wario = factory()\n}(this, function () { 'use strict';\n\n  const rps = {\n    core: {\n      replace: /(\\r\\n|\\n|\\r)/gm\n    },\n    each: {\n      matchChunk: /(({{#each(.*?)}})(.*?){{\\/each}})/g,\n      matchAttribute: /{{#each (.*?)}}/,\n      replace: /({{#each (.+?)}})|{{\\/each}}/g\n    },\n    rpv: {\n      match: /{{([^}]*)}}/g,\n      replace: /({{|}})/g\n    }\n  };\n\n  function getNested(obj, key) {\n    const parts = key.split('.');\n    const realKey = parts[0];\n    const attribute = obj[realKey];\n    if (parts.length > 1) {\n      return getNested(attribute, parts.slice(1).join('.'));\n    } else {\n      return attribute;\n    }\n  }\n\n  function parseEach(string, obj) {\n    const pattern = rps.each.matchChunk;\n    const parsed = string.match(pattern).reduce((result, m) => {\n      let key = m.match(rps.each.matchAttribute)[1];\n      let matchVal = getNested(obj, key);\n      let newText = matchVal.map((value) => {\n        return replaceValues(m.replace(rps.each.replace, ''), value);\n      });\n\n      return result.replace(m, newText.join(''));\n    }, string);\n\n    return parsed;\n  }\n\n  function replaceValues(string, obj) {\n    const matches = string.match(rps.rpv.match);\n    if (!matches) { return string; }\n    const parsed = matches.reduce((result, m) => {\n      let key = m.replace(rps.rpv.replace, '');\n      let matchVal = getNested(obj, key);\n      return result.replace(m, matchVal);\n    }, string);\n\n    return parsed;\n  }\n\n  function parseTemplate(template, obj) {\n    const source = template.replace(rps.core.replace,'').trim();\n    if (template.indexOf('{{#each') > -1) {\n      return replaceValues(parseEach(source, obj), obj);\n    }\n    return replaceValues(source, obj);\n  }\n\n  var wario = parseTemplate;\n\n  return wario;\n\n}));\n","const rps = {\n  core: {\n    replace: /(\\r\\n|\\n|\\r)/gm\n  },\n  each: {\n    matchChunk: /(({{#each(.*?)}})(.*?){{\\/each}})/g,\n    matchAttribute: /{{#each (.*?)}}/,\n    replace: /({{#each (.+?)}})|{{\\/each}}/g\n  },\n  rpv: {\n    match: /{{([^}]*)}}/g,\n    replace: /({{|}})/g\n  }\n};\n\nfunction getNested(obj, key) {\n  const parts = key.split('.');\n  const realKey = parts[0];\n  const attribute = obj[realKey];\n  if (parts.length > 1) {\n    return getNested(attribute, parts.slice(1).join('.'));\n  } else {\n    return attribute;\n  }\n}\n\nfunction parseEach(string, obj) {\n  const pattern = rps.each.matchChunk;\n  const parsed = string.match(pattern).reduce((result, m) => {\n    let key = m.match(rps.each.matchAttribute)[1];\n    let matchVal = getNested(obj, key);\n    let newText = matchVal.map((value) => {\n      return replaceValues(m.replace(rps.each.replace, ''), value);\n    });\n\n    return result.replace(m, newText.join(''));\n  }, string);\n\n  return parsed;\n}\n\nfunction replaceValues(string, obj) {\n  const matches = string.match(rps.rpv.match);\n  if (!matches) { return string; }\n  const parsed = matches.reduce((result, m) => {\n    let key = m.replace(rps.rpv.replace, '');\n    let matchVal = getNested(obj, key);\n    return result.replace(m, matchVal);\n  }, string);\n\n  return parsed;\n}\n\nfunction parseTemplate(template, obj) {\n  const source = template.replace(rps.core.replace,'').trim();\n  if (template.indexOf('{{#each') > -1) {\n    return replaceValues(parseEach(source, obj), obj);\n  }\n  return replaceValues(source, obj);\n}\n\nexport default parseTemplate;\n","(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.wario = factory();\n})(this, function () {\n  'use strict';\n\n  var rps = {\n    core: {\n      replace: /(\\r\\n|\\n|\\r)/gm\n    },\n    each: {\n      matchChunk: /(({{#each(.*?)}})(.*?){{\\/each}})/g,\n      matchAttribute: /{{#each (.*?)}}/,\n      replace: /({{#each (.+?)}})|{{\\/each}}/g\n    },\n    rpv: {\n      match: /{{([^}]*)}}/g,\n      replace: /({{|}})/g\n    }\n  };\n\n  function getNested(_x, _x2) {\n    var _again = true;\n\n    _function: while (_again) {\n      var obj = _x,\n          key = _x2;\n      _again = false;\n\n      var parts = key.split('.');\n      var realKey = parts[0];\n      var attribute = obj[realKey];\n      if (parts.length > 1) {\n        _x = attribute;\n        _x2 = parts.slice(1).join('.');\n        _again = true;\n        parts = realKey = attribute = undefined;\n        continue _function;\n      } else {\n        return attribute;\n      }\n    }\n  }\n\n  function parseEach(string, obj) {\n    var pattern = rps.each.matchChunk;\n    var parsed = string.match(pattern).reduce(function (result, m) {\n      var key = m.match(rps.each.matchAttribute)[1];\n      var matchVal = getNested(obj, key);\n      var newText = matchVal.map(function (value) {\n        return replaceValues(m.replace(rps.each.replace, ''), value);\n      });\n\n      return result.replace(m, newText.join(''));\n    }, string);\n\n    return parsed;\n  }\n\n  function replaceValues(string, obj) {\n    var matches = string.match(rps.rpv.match);\n    if (!matches) {\n      return string;\n    }\n    var parsed = matches.reduce(function (result, m) {\n      var key = m.replace(rps.rpv.replace, '');\n      var matchVal = getNested(obj, key);\n      return result.replace(m, matchVal);\n    }, string);\n\n    return parsed;\n  }\n\n  function parseTemplate(template, obj) {\n    var source = template.replace(rps.core.replace, '').trim();\n    if (template.indexOf('{{#each') > -1) {\n      return replaceValues(parseEach(source, obj), obj);\n    }\n    return replaceValues(source, obj);\n  }\n\n  var wario = parseTemplate;\n\n  return wario;\n});\n//# sourceMappingURL=wario.js.map\n"],"sourceRoot":"/source/"}